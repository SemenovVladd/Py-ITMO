from typing import Callable
#импортируем функции ввиде типов
def gen_bin_tree1 (root:int, height: int,
                  l: callable, r:callable) -> dict:
    # создаем функцию от корня, высоты и формул для левых и правых продолжений
    if height==1:
        return {str(root): []}
    #если высота равна 1, возращаем список из корня и массива
    return {str(root):[gen_bin_tree1(l(root), height-1,l,r),
                       gen_bin_tree1(l(root), height-1,l,r)]}
    #возращаем для каждого корня левого и правого потомка

def gen_bin_tree2 (height: int, root: int,
                  left_branch: callable,
                  right_branch: callable):
    #создаем функцию, принимающую на вход высоту, корень, и формулы для потомков

    res = {str(root): []}
    #создаем начальный словарик
    q = Queue()
    #создаем очередь
    q.put((res, 0))
    #в очередь помещаем изначальные значаения (корень + высота)

    while not q.empty():
        now_node, now_height = q.get()
        #получаем значение текущего узла и высоту
        if now_height >= height:
            continue
        #если не достигли максимальной высоты, продолжаем
        current_key = list(now_node.keys())[0]
        #получаем ключ узла
        left_value = left_branch(int(current_key))
        right_value = right_branch(int(current_key))
        #вычисляем значения левого и правого потомка
        left_child = {str(left_value): []}
        right_child = {str(right_value): []}
        #Создаем новые узлы
        now_node[current_key].append(left_child)
        now_node[current_key].append(right_child)
        #добавляем потомков к рассматриваемому узлу
        q.put((left_child, now_height + 1))
        q.put((right_child, now_height + 1))
        #и отправляем их в очередь с высотой + 1

    return res
    #возращаем результат









def time_func(func, n, repeats=5):
    #функиця для измерения времени выполнения другой функции
    #func - сама функция, которую будем тестировать
    #n - значение, которое принимает функция
    #repeats - количество повторений
    if func == gen_bin_tree2:
        timer = timeit.Timer(lambda: func(n, 18, lambda x: (x - 8) * 3, lambda x: (x + 8) * 2))
    if func == gen_bin_tree1:
        timer = timeit.Timer(lambda: func(18, n, lambda x: (x - 8) * 3, lambda x: (x + 8) * 2))
    #объект таймера, который принимает функцию с числом внутри нее(для этого использовал lambda, иначе не работало)
    #тут 2 разных объекта, т.к. изначально перепутал высоту и корень у первой функции
    times = timer.repeat(repeat=repeats, number=10)
    #измеряем время
    return (times[repeats//2+1])
    # возвращаем среднее время среди 5 (в данном случае) больших повторений





max_n = 10
#до какой высоты будем строить дерево
t_tree_rec = []
#массив для время функции через рекурсию
t_tree_not_rec = []
#массив для время функции без рекурсии

for n in range(1,max_n):
    #проходимся по значениям от 1 до 10
    t = time_func(gen_bin_tree1, n)
    t_tree_rec.append(t)
    #вычисляем время и записываем в массив

    t = time_func(gen_bin_tree2, n)
    t_tree_not_rec.append(t)
    #вычисляем время и записываем в массив


#построение графика
plt.figure(figsize=(8, 6))
plt.plot(t_tree_rec, label="fact_rec")
plt.plot(t_tree_not_rec, label="fact_not_rec")
#строим сами графики
plt.xlabel("высота дерева")
plt.ylabel("Время выполнения функции")
#подписываем их
plt.title("Сравнение времени построения деревьев")
#называем сам плот
plt.legend()
#добавляем легенду
plt.grid(True)
#сетка для наглядности
plt.tight_layout()
plt.show()



