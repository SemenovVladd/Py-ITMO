В рамках выполнения лаболаторной сделал алгоритм построения бинарного дерева без рекурсии (для этого использовал очереди)
На выход функция принимает начальное значение (корень), высоту и 2 lambda функции (использовал для своего варианта)
Возращает словарь со значениями узлов и листьев бинарного дерева 
Вот такой словарик получился:
{'18': [{'30': [{'66': [{'174': [{'498': [{'1470': []}, {'1012': []}]}, {'364': [{'1068': []}, {'744': []}]}]}, {'148': [{'420': [{'1236': []}, {'856': []}]}, {'312': [{'912': []}, {'640': []}]}]}]}, {'76': [{'204': [{'588': [{'1740': []}, {'1192': []}]}, {'424': [{'1248': []}, {'864': []}]}]}, {'168': [{'480': [{'1416': []}, {'976': []}]}, {'352': [{'1032': []}, {'720': []}]}]}]}]}, {'52': [{'132': [{'372': [{'1092': [{'3252': []}, {'2200': []}]}, {'760': [{'2256': []}, {'1536': []}]}]}, {'280': [{'816': [{'2424': []}, {'1648': []}]}, {'576': [{'1704': []}, {'1168': []}]}]}]}, {'120': [{'336': [{'984': [{'2928': []}, {'1984': []}]}, {'688': [{'2040': []}, {'1392': []}]}]}, {'256': [{'744': [{'2208': []}, {'1504': []}]}, {'528': [{'1560': []}, {'1072': []}]}]}]}]}]}
